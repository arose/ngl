<!DOCTYPE html>
<html lang="en">
    <head>
        <title>NGL</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            
            html {
                height: 100%;
            }

            body {
                color: #ffffff;
                font-family:Monospace;
                font-size:13px;
                font-weight: bold;

                background-color: #000000;
                margin: 0px;
                overflow: hidden;

                width: 100%;
                height: 100%;
            }
            
            #info {
                color: #fff;
                background-color: rgba( 0, 0, 0, 0.75 );
                position: relative;
                text-align:center;
                top: 0px; 
                width: 100%;
                padding: 5px;
                z-index:100;
                width:33em;
                margin:0 auto -2em;
            }
            
            a { color: #ff0000 }

            #container {
                width: 100%;
                height: 100%;
            }

            /*.dg li:not(.folder) {
                background: rgba(0, 0, 0, 0.75) !important;
            }*/

        </style>
    </head>

    <body>
        <div id="info">NGL</div>
        <div id="container"></div>

        <script src="js/three.js"></script>
        <script src="js/three/Detector.js"></script>
        <script src="js/three/libs/dat.gui.min.js"></script>
        <script src="js/three/libs/stats.min.js"></script>
        <script src="js/three/controls/TrackballControls.js"></script>
        <script src="js/three/loaders/OBJLoader.js"></script>

        <script src="js/three/shaders/CopyShader.js"></script>
        <script src="js/three/shaders/SSAOShader.js"></script>
        <script src="js/three/shaders/FXAAShader.js"></script>
        <script src="js/three/shaders/DotScreenShader.js"></script>

        <script src="js/three/postprocessing/EffectComposer.js"></script>
        <script src="js/three/postprocessing/RenderPass.js"></script>
        <script src="js/three/postprocessing/MaskPass.js"></script>
        <script src="js/three/postprocessing/ShaderPass.js"></script>

        <script src="js/threex.rendererstats.js"></script>

        <script src="js/ngl.js"></script>
        <script src="js/ngl.wip.js"></script>
        <script src="js/ngl.alt.js"></script>
        <script src="js/ngl.extra.js"></script>



        <script>

            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();


            document.addEventListener("DOMContentLoaded", function() {

                NGL.init( function(){

                    var viewer = new NGL.Viewer( 'container' );
                    viewer.animate();

                    var gui = new NGL.showcaseGui( viewer );

                    gui.addStructure( "data/1blu.pdb" );
                    
                    // gui.surfaceId = '1crn';
                    // gui.addSurface();

                });

            });


            NGL.showcaseGui = function( viewer ){

                this.viewer = viewer;
                this.gui = viewer.gui.gui;

                var primitives = this.gui.addFolder( 'Primitives' );
                primitives.add( this, 'count', [ 
                    1, 10, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000,
                    100000, 200000, 500000, 1000000, 2000000
                ]);
                primitives.add( this, 'size', 2.0).min(0.1).max(10.0).step(0.1);
                primitives.add( this, 'primitiveType', [
                    'BezierRaymarch',
                    'BezierImpostor',
                    'EllipticBezierImpostor',
                    'Bezier',
                    'HelixImpostor',
                    'HelixImpostor2',
                    'SphereImpostor',
                    'SphereMesh',
                    'Sphere',
                    'Point',
                    'ParticleSprite',
                    'CylinderImpostor',
                    'Cylinder',
                    'QuadricImpostor',
                    'HyperballSphereImpostor',
                    'HyperballStickImpostor',
                    'Line',
                    'LineSprite',
                    'Halo',
                    'Text',
                    'SceneImpostor',
                    'Scene',
                    'SceneSimple',
                    'SceneSprite',
                    'Surface'
                ]).listen();
                primitives.add( this, 'addPrimitive' );

                var surfaces = this.gui.addFolder( 'Surfaces' );
                surfaces.add( this, 'surfaceId', [ 
                    '1crn',
                    '3dqb'
                ]).listen();
                surfaces.add( this, 'addSurface' );

                var structure = this.gui.addFolder( 'Structure' );
                structure.add( this, 'structureFile', [
                    'hem.pdb',
                    '1crn.pdb',
                    '1blu.pdb',
                    '1d66.pdb',
                    '3dqb.pdb',
                    '3pqr.pdb',
                    '3sn6.pdb',
                    '1jj2.pdb',
                    '3l5q.pdb',
                    'md.pdb',
                    'md.gro',
                    'md_large.gro',
                ]).listen().onChange( function( value ){

                    this.structureFile = "";
                    this.addStructure( 'data/' + value );

                }.bind( this ) );
                structure.add( this, 'pdbId' ).listen().onFinishChange( function( value ){
                    
                    if( value.length!==4 ) return;

                    this.pdbId = "";
                    this.addStructure( value.toUpperCase() );

                }.bind( this ) );
                structure.add( this, 'selectFile' );

                this.fileInput = document.createElement("input");
                this.fileInput.type = "file";
                this.fileInput.multiple = true;
                this.fileInput.style = "visibility:hidden";
                this.fileInput.addEventListener('change', function( e ){

                    var fileList = e.target.files;
                    var n = fileList.length;

                    for( var i=0; i<n; ++i ){

                        this.addStructure( fileList[ i ] );

                    }

                }.bind( this ), false);

            }

            NGL.showcaseGui.prototype = {

                count: 100,
                size: 2.0,
                primitiveType: 'SphereImpostor',
                structureFile: '',
                pdbId: '',
                surfaceId: '1crn',

                selectFile: function(){

                    var elm = document.getElementById( "myInput" );

                    this.fileInput.dispatchEvent( new MouseEvent('click', {
                        'view': window,
                        'bubbles': true,
                        'cancelable': true
                    }));

                },

                addPrimitive: function(){

                    loadPrimitive(
                        this.count, this.size, this.primitiveType, this.viewer
                    );

                },

                addStructure: function( path ){

                    new NGL.StructureLoader( 
                        path,
                        this.viewer,
                        function( structure ){
                            structure.add( "backbone" );
                            structure.add( "ball+stick", "hetero" );
                            structure.center();
                        }
                    );

                },

                addSurface: function(){

                    loadSurface( 
                        'data/' + this.surfaceId + '.obj', this.viewer
                    );

                }

            }


            function loadPrimitive( count, size, primitiveType, viewer ){

                var c1 = makeCylinderData( count, size );
                var r1 = new Float32Array( c1.radius.length );
                for( var i = 0; i < c1.radius.length; i++ ){
                    r1[ i ] = size * 2.5;
                }
                var types = {
                    'BezierRaymarch': function(){
                        var bd = makeBezierData( count, size );
                        new NGL.BezierRaymarchBuffer( bd.p0, bd.p1, bd.p2, bd.color, bd.radius );

                        // new NGL.SphereImpostorBuffer( bd.p0, bd.color, bd.radius );
                        // new NGL.SphereImpostorBuffer( bd.p1, bd.color, bd.radius );
                        // new NGL.SphereImpostorBuffer( bd.p2, bd.color, bd.radius );
                    },
                    'BezierImpostor': function(){
                        var bd = makeBezierData( count, size );
                        new NGL.BezierImpostorBuffer( bd.p0, bd.p1, bd.p2, bd.color, bd.radius, 2 );

                        // new NGL.SphereImpostorBuffer( bd.p0, bd.color, bd.radius );
                        // new NGL.SphereImpostorBuffer( bd.p1, bd.color, bd.radius );
                        // new NGL.SphereImpostorBuffer( bd.p2, bd.color, bd.radius );
                    },
                    'EllipticBezierImpostor': function(){
                        var bd = makeBezierData( count, size );
                        new NGL.EllipticBezierImpostorBuffer( 
                            bd.p0, bd.p1, bd.p2, bd.color, bd.radius, 3
                        );
                        
                        // new NGL.BezierImpostorBuffer( bd.p0, bd.p1, bd.p2, bd.color, bd.radius, 2 );

                        new NGL.SphereImpostorBuffer( bd.p0, bd.color, bd.radius );
                        new NGL.SphereImpostorBuffer( bd.p1, bd.color, bd.radius );
                        new NGL.SphereImpostorBuffer( bd.p2, bd.color, bd.radius );
                    },
                    'Bezier': function(){
                        var bd = makeBezierData( count, size );
                        new NGL.BezierGroup( bd.p0, bd.p1, bd.p2, bd.color, bd.radius );
                    },
                    'HelixImpostor': function(){
                        var hd = makeHelixData( count, size );
                        new NGL.HelixImpostorBuffer( 
                            hd.from, hd.to, hd.vFrom, hd.color, hd.color, hd.radius
                        );

                        // new NGL.CylinderImpostorBuffer( 
                        //     hd.from, hd.to, hd.color, hd.color, hd.radius
                        // );

                        var sr = new Float32Array( hd.radius.length );
                        for( var i = 0; i < hd.radius.length; i++ ){
                            sr[ i ] = size / 4.0;
                        }
                        new NGL.SphereImpostorBuffer( hd.pFrom, hd.color, sr );
                        new NGL.SphereImpostorBuffer( hd.pTo, hd.color, sr );
                    },
                    'HelixImpostor2': function(){
                        var hd = makeHelixData( count, size );
                        new NGL.HelixImpostorBuffer2( 
                            hd.from, hd.to, hd.vFrom, hd.color, hd.color, hd.radius
                        );

                        // new NGL.CylinderImpostorBuffer( 
                        //     hd.from, hd.to, hd.color, hd.color, hd.radius
                        // );

                        var sr = new Float32Array( hd.radius.length );
                        for( var i = 0; i < hd.radius.length; i++ ){
                            sr[ i ] = size / 4.0;
                        }
                        new NGL.SphereImpostorBuffer( hd.pFrom, hd.color, sr );
                        new NGL.SphereImpostorBuffer( hd.pTo, hd.color, sr );
                    },
                    'SphereImpostor': function(){
                        viewer.add(
                            new NGL.SphereImpostorBuffer( c1.from, c1.color, r1 )
                        );
                    },
                    'SphereMesh': function(){
                        new NGL.SphereMeshBuffer( c1.to, c1.color, r1 );
                    },
                    'Sphere': function(){
                        viewer.add( new NGL.SphereGroup( c1.to, c1.color, r1 ) );
                    },
                    'Point': function(){
                        viewer.add( new NGL.PointBuffer( c1.from, c1.color, size ) );
                    },
                    'ParticleSprite': function(){
                        new NGL.ParticleSpriteBuffer( c1.from, c1.color, r1 );
                    },
                    'CylinderImpostor': function(){
                        viewer.add( new NGL.CylinderImpostorBuffer( 
                            c1.from, c1.to, c1.color, c1.color, c1.radius
                        ) );
                        // viewer.add( new NGL.CylinderBoxImpostorBuffer( 
                        //     c1.from, c1.to, c1.color, c1.color, c1.radius
                        // ) );
                    },
                    'Cylinder': function(){
                        new NGL.CylinderGroup( c1.from, c1.to, c1.color, c1.radius );
                    },
                    'QuadricImpostor': function(){
                        var qlist = [
                            // "EllipsoidImpostorBuffer", "HyperboloidOneImpostorBuffer",
                            // "HyperboloidTwoImpostorBuffer", 
                            "ConeImpostorBuffer",
                            // "EllipticCylinderImpostorBuffer"
                        ]
                        var n = qlist.length;
                        var m = Math.floor( size / n );
                        var qd;

                        var r1 = new Float32Array( count );
                        for( var i = 0; i < count; i++ ){
                            r1[ i ] = size / 3.0;
                        }
                        
                        for( var i = 0; i < n; ++i ){
                            qd = makeQuadricData( count, m );
                            new NGL.SphereImpostorBuffer( qd.xpos, qd.color, r1 );
                            new NGL.SphereImpostorBuffer( qd.ypos, qd.color, r1 );
                            new NGL.SphereImpostorBuffer( qd.zpos, qd.color, r1 );
                            new NGL.SphereImpostorBuffer( qd.position, qd.color, r1 );
                            new NGL[ qlist[i] ]( 
                                qd.position, qd.xdir, qd.ydir, qd.zdir, qd.color
                            );
                        }
                    },
                    'HyperballSphereImpostor': function(){
                        new NGL.HyperballSphereImpostorBuffer( c1.from, c1.color, r1 );
                    },
                    'HyperballStickImpostor': function(){
                        new NGL.HyperballStickImpostorBuffer(
                            c1.from, c1.to, c1.color, c1.color, c1.radius, c1.radius, 0.05
                        );
                    },
                    'Line': function(){
                        new NGL.LineBuffer( c1.from, c1.to, c1.color, c1.color );
                    },
                    'LineSprite': function(){
                        new NGL.LineSpriteBuffer( c1.from, c1.to, c1.color, c1.color, c1.radius );
                    },
                    'Halo': function(){
                        new NGL.HaloBuffer( c1.from, r1 );
                    },
                    'Text': function(){
                        viewer.add( new NGL.TextBuffer( c1.to, c1.radius ) );
                    },
                    'SceneImpostor': function(){
                        new NGL.SphereImpostorBuffer( c1.from, c1.color, r1 );
                        new NGL.SphereImpostorBuffer( c1.to, c1.color, c1.radius );
                        new NGL.CylinderImpostorBuffer( 
                            c1.from, c1.to, c1.color, c1.color, c1.radius, true
                        );
                        new NGL.HaloBuffer( c1.from, r1 );
                        new NGL.TextBuffer( c1.to, c1.radius );
                    },
                    'SceneSphereTest': function(){
                        new NGL.SphereImpostorBuffer( c1.from, c1.color, r1 );
                        new NGL.SphereGroup( c1.to, c1.color, r1 );
                    },
                    'Scene': function(){
                        new NGL.SphereGroup( c1.from, c1.color, r1 );
                        new NGL.SphereGroup( c1.to, c1.color, r1 );
                        new NGL.CylinderGroup( 
                            c1.from, c1.to, c1.color, c1.radius
                        );
                        new NGL.HaloBuffer( c1.from, r1 );
                        new NGL.TextBuffer( c1.to, c1.radius );
                    },
                    'SceneSimple': function(){
                        new NGL.PointBuffer( c1.from, c1.color, size );
                        new NGL.PointBuffer( c1.to, c1.color, size );
                        new NGL.LineBuffer( 
                            c1.from, c1.to, c1.color, c1.color, c1.radius
                        );
                        new NGL.HaloBuffer( c1.from, r1, true );
                        new NGL.TextBuffer( c1.to, c1.radius );
                    },
                    'SceneSprite': function(){
                        new NGL.ParticleSpriteBuffer( c1.from, c1.color, r1 );
                        new NGL.ParticleSpriteBuffer( c1.to, c1.color, r1 );
                        new NGL.LineSpriteBuffer( 
                            c1.from, c1.to, c1.color, c1.color, c1.radius
                        );
                        new NGL.HaloBuffer( c1.from, r1, true );
                        new NGL.TextBuffer( c1.to, c1.radius );
                    }
                }
                types[ primitiveType ]();
                viewer.render();

            }


            function loadSurface( url, viewer ){

                var loader = new THREE.OBJLoader();
                loader.load( url, function ( object ) {

                    var surface = new THREE.Object3D();

                    var geo = object.children[0].geometry;
                    console.log(geo);
                    
                    var position = NGL.Utils.positionFromGeometry( geo );
                    var color = NGL.Utils.colorFromGeometry( geo );
                    var index = NGL.Utils.indexFromGeometry( geo );
                    var normal = NGL.Utils.normalFromGeometry( geo );
                    
                    viewer.add( new NGL.MeshBuffer( position, color, index, normal ) );

                    viewer.render();

                } );

            }


            var RAND = Math.random;


            function makeSphereData( n, size ){
                var cube = 100;
                var n3 = n * 3;

                var radius = new Float32Array( n );
                var color = new Float32Array( n3 );
                var position = new Float32Array( n3 );

                var j;
                for( var i = 0; i < n; i++ ) {
                    j = 3 * i;
                    radius[ i ] = size;
                    color[ j + 0 ] = Math.random();
                    color[ j + 1 ] = Math.random();
                    color[ j + 2 ] = Math.random();
                    position[ j + 0 ] = (Math.random() * 2 - 1) * cube;
                    position[ j + 1 ] = (Math.random() * 2 - 1) * cube;
                    position[ j + 2 ] = (Math.random() * 2 - 1) * cube;
                }

                position[ 0 ] = 0.0;
                position[ 1 ] = 0.0;
                position[ 2 ] = 0.0;

                return {
                    "radius": radius,
                    "color": color,
                    "position": position
                }
            }


            function makeCylinderData( n, size ){
                var cube = 100;
                var n3 = n * 3;

                var radius = new Float32Array( n );
                var color = new Float32Array( n3 );
                var from = new Float32Array( n3 );
                var to = new Float32Array( n3 );

                var x, y, z;
                var a, b, c;

                var vPos = new THREE.Vector3();

                var j;
                for( var i = 0; i < n; i++ ) {
                    j = 3 * i;
                    radius[ i ] = size;
                    color[ j + 0 ] = Math.random();
                    color[ j + 1 ] = Math.random();
                    color[ j + 2 ] = Math.random();

                    x = (Math.random() * 2 - 1) * cube;
                    y = (Math.random() * 2 - 1) * cube;
                    z = (Math.random() * 2 - 1) * cube;

                    a = Math.random() * 10;
                    b = Math.random() * 10;
                    c = Math.random() * 10;

                    from[ j + 0 ] = x + a;
                    from[ j + 1 ] = y + b;
                    from[ j + 2 ] = z + c;

                    to[ j + 0 ] = x - a;
                    to[ j + 1 ] = y - b;
                    to[ j + 2 ] = z - c;
                }

                return {
                    "radius": radius,
                    "color": color,
                    "from": from,
                    "to": to
                }
            }


            function makeQuadricData( n, size ){
                var cube = 100;
                var n3 = n * 3;

                var position = new Float32Array( n3 );
                var color = new Float32Array( n3 );

                var xdir = new Float32Array( n3 );
                var ydir = new Float32Array( n3 );
                var zdir = new Float32Array( n3 );

                var xpos = new Float32Array( n3 );
                var ypos = new Float32Array( n3 );
                var zpos = new Float32Array( n3 );

                var px = new THREE.Vector3();
                var py = new THREE.Vector3();
                var pz = new THREE.Vector3();

                var vx = new THREE.Vector3();
                var vy = new THREE.Vector3();
                var vz = new THREE.Vector3();

                var j, x, y, z;

                for( var i = 0; i < n; i++ ) {
                    j = 3 * i;

                    if( i==0 ){
                        x = 0;
                        y = 0;
                        z = 0;
                    }else{
                        x = (RAND() * 2 - 1) * cube;
                        y = (RAND() * 2 - 1) * cube;
                        z = (RAND() * 2 - 1) * cube;
                    }

                    position[ j + 0 ] = x;
                    position[ j + 1 ] = y;
                    position[ j + 2 ] = z;

                    color[ j + 0 ] = RAND();
                    color[ j + 1 ] = RAND();
                    color[ j + 2 ] = RAND();

                    // vx.set( RAND(), RAND(), RAND() )
                    //     .setLength( size * 8 );
                    // vy.set( RAND(), RAND(), RAND() ).cross( vx )
                    //     .setLength( size * 4 );
                    // vz.crossVectors( vx, vy )
                    //     .setLength( size * 2 );

                    vx.set( RAND(), RAND(), RAND() )
                        .setLength( 0.5 + RAND() * 10 );
                    vy.set( RAND(), RAND(), RAND() ).cross( vx )
                        .setLength( 0.5 + RAND() * 10 );
                    vz.crossVectors( vx, vy )
                        .setLength( 0.5 + RAND() * 10 );

                    xdir[ j + 0 ] = vx.x;
                    xdir[ j + 1 ] = vx.y;
                    xdir[ j + 2 ] = vx.z;

                    ydir[ j + 0 ] = vy.x;
                    ydir[ j + 1 ] = vy.y;
                    ydir[ j + 2 ] = vy.z;

                    zdir[ j + 0 ] = vz.x;
                    zdir[ j + 1 ] = vz.y;
                    zdir[ j + 2 ] = vz.z;

                    px.set( x, y, z ).add( vx );
                    py.set( x, y, z ).add( vy );
                    pz.set( x, y, z ).add( vz );

                    xpos[ j + 0 ] = px.x;
                    xpos[ j + 1 ] = px.y;
                    xpos[ j + 2 ] = px.z;

                    ypos[ j + 0 ] = py.x;
                    ypos[ j + 1 ] = py.y;
                    ypos[ j + 2 ] = py.z;

                    zpos[ j + 0 ] = pz.x;
                    zpos[ j + 1 ] = pz.y;
                    zpos[ j + 2 ] = pz.z;
                }

                return {
                    "position": position,
                    "color": color,
                    "xdir": xdir,
                    "ydir": ydir,
                    "zdir": zdir,
                    "xpos": xpos,
                    "ypos": ypos,
                    "zpos": zpos
                }
            }


            function makeHelixData( n, size ){
                var cube = 100;
                var n3 = n * 3;

                var radius = new Float32Array( n );
                var color = new Float32Array( n3 );
                var from = new Float32Array( n3 );
                var to = new Float32Array( n3 );
                
                var vFrom = new Float32Array( n3 );
                var vTo = new Float32Array( n3 );
                var pFrom = new Float32Array( n3 );
                var pTo = new Float32Array( n3 );

                var x, y, z;
                var a, b, c;

                var vAxis = new THREE.Vector3();
                var vRand = new THREE.Vector3();
                var vCross = new THREE.Vector3();

                var j;
                for( var i = 0; i < n; i++ ) {
                    j = 3 * i;
                    radius[ i ] = size;
                    color[ j + 0 ] = Math.random();
                    color[ j + 1 ] = Math.random();
                    color[ j + 2 ] = Math.random();

                    x = (Math.random() * 2 - 1) * cube;
                    y = (Math.random() * 2 - 1) * cube;
                    z = (Math.random() * 2 - 1) * cube;

                    a = Math.random() * 10;
                    b = Math.random() * 10;
                    c = Math.random() * 10;

                    from[ j + 0 ] = x + a;
                    from[ j + 1 ] = y + b;
                    from[ j + 2 ] = z + c;

                    to[ j + 0 ] = x - a;
                    to[ j + 1 ] = y - b;
                    to[ j + 2 ] = z - c;

                    vAxis.set( x + a - (x - a), y + b - (y - b), z + c - (z - c) );
                    vRand.set( Math.random(), Math.random(), Math.random() );
                    vCross.crossVectors( vAxis, vRand );

                    vFrom[ j + 0 ] = vCross.x;
                    vFrom[ j + 1 ] = vCross.y;
                    vFrom[ j + 2 ] = vCross.z;

                    vTo[ j + 0 ] = -vCross.x;
                    vTo[ j + 1 ] = -vCross.y;
                    vTo[ j + 2 ] = -vCross.z;

                    vCross.normalize().multiplyScalar( size );

                    pFrom[ j + 0 ] = from[ j + 0 ] + vCross.x;
                    pFrom[ j + 1 ] = from[ j + 1 ] + vCross.y;
                    pFrom[ j + 2 ] = from[ j + 2 ] + vCross.z;

                    pTo[ j + 0 ] = to[ j + 0 ] - vCross.x;
                    pTo[ j + 1 ] = to[ j + 1 ] - vCross.y;
                    pTo[ j + 2 ] = to[ j + 2 ] - vCross.z;
                }

                return {
                    "radius": radius,
                    "color": color,
                    "from": from,
                    "to": to,
                    "vFrom": vFrom,
                    "vTo": vTo,
                    "pFrom": pFrom,
                    "pTo": pTo
                }
            }


            function makeBezierData( n, size ){
                var cube = 100;
                var n3 = n * 3;

                var radius = new Float32Array( n );
                var color = new Float32Array( n3 );
                var p0 = new Float32Array( n3 );
                var p1 = new Float32Array( n3 );
                var p2 = new Float32Array( n3 );

                var x, y, z;
                var a, b, c;

                var vPos = new THREE.Vector3();

                var j;
                for( var i = 0; i < n; i++ ) {
                    j = 3 * i;
                    radius[ i ] = size;
                    color[ j + 0 ] = Math.random();
                    color[ j + 1 ] = Math.random();
                    color[ j + 2 ] = Math.random();

                    if( i==0 ){
                        x = 0;
                        y = 0;
                        z = 0;
                    }else{
                        x = (Math.random() * 2 - 1) * cube;
                        y = (Math.random() * 2 - 1) * cube;
                        z = (Math.random() * 2 - 1) * cube;
                    }

                    a = Math.random() * 10;
                    b = Math.random() * 10;
                    c = Math.random() * 10;

                    p0[ j + 0 ] = x + a;
                    p0[ j + 1 ] = y + b;
                    p0[ j + 2 ] = z + c;

                    p1[ j + 0 ] = x;
                    p1[ j + 1 ] = y;
                    p1[ j + 2 ] = z;

                    p2[ j + 0 ] = x - 1.41*a;
                    p2[ j + 1 ] = y;
                    p2[ j + 2 ] = z;
                }

                return {
                    "radius": radius,
                    "color": color,
                    "p0": p0,
                    "p1": p1,
                    "p2": p2
                }
            }


        </script>

    </body>

</html>
